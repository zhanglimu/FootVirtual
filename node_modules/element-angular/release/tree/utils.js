export const /** @type {?} */ notEmptyArray = (arr) => {
    if (!Array.isArray(arr))
        return false;
    return arr && arr.length > 0;
};
export const /** @type {?} */ makeRandomID = () => Math.random().toString(16).slice(-8);
export class ModelStandard {
    /**
     * @param {?} init
     */
    constructor(init) {
        this.init = init;
    }
    /**
     * @param {?} models
     * @return {?}
     */
    static LoopRemoveChecked(models) {
        models.forEach(item => {
            item.checked = false;
            if (item.children && item.children.length) {
                ModelStandard.LoopRemoveChecked(item.children);
            }
        });
    }
    /**
     * @param {?} id
     * @param {?} models
     * @param {?} accordion
     * @return {?}
     */
    static DeepUpdateExpanded(id, models, accordion) {
        if (!models || !models.length)
            return [];
        const /** @type {?} */ index = models.findIndex(item => item.id === id);
        if (index === -1)
            return models.map(item => Object.assign(item, {
                children: ModelStandard.DeepUpdateExpanded(id, item.children || [], accordion)
            }));
        // in accordion mode, only open one.
        // dont return new object, new object will cause the component to be re rendered,
        // and the current animation may be lost.
        const /** @type {?} */ nextExpanded = !models[index].expanded;
        if (accordion) {
            models = models.map(item => Object.assign(item, {
                expanded: false
            }));
        }
        models[index].expanded = nextExpanded;
        return models;
    }
    /**
     * @param {?} id
     * @param {?} models
     * @return {?}
     */
    static DeepUpdateChecked(id, models) {
        if (!models || !models.length)
            return [];
        const /** @type {?} */ index = models.findIndex(item => item.id === id);
        if (index === -1) {
            models.forEach(item => {
                const /** @type {?} */ nextChildren = ModelStandard.DeepUpdateChecked(id, item.children || []);
                const /** @type {?} */ nextIndeterminate = !!nextChildren.find(item => item.checked || item._indeterminate);
                const /** @type {?} */ allChecked = nextChildren.length > 0 && !nextChildren.find(item => !item.checked);
                item._indeterminate = allChecked ? false : nextIndeterminate;
                item.children = nextChildren;
                // leaf have have no subelements so no need to be updatedã€‚
                // leaf element is not affected by subelements.
                if (nextChildren.length) {
                    item.checked = allChecked;
                }
            });
            return models;
        }
        models[index].checked = !models[index].checked;
        models[index]._indeterminate = false;
        if (models[index].children && models[index].children.length > 0) {
            ModelStandard.SetChildrenChecked(models[index].children, models[index].checked);
        }
        return models;
    }
    /**
     * @param {?} models
     * @param {?} checked
     * @return {?}
     */
    static SetChildrenChecked(models, checked) {
        models.forEach(item => {
            item.checked = checked;
            if (item.children && item.children.length) {
                ModelStandard.SetChildrenChecked(item.children, checked);
            }
        });
    }
    /**
     * @param {?} models
     * @return {?}
     */
    static FindAllChecked(models) {
        const /** @type {?} */ checkedLabels = models.reduce((labels = [], item) => {
            const /** @type {?} */ childrenLabels = (item.children && item.children.length)
                ? ModelStandard.FindAllChecked(item.children)
                : [];
            return labels.concat(...childrenLabels, item.checked ? item.label : []);
        }, []);
        return checkedLabels;
    }
    /**
     * @param {?} models
     * @return {?}
     */
    filterModel(models) {
        return this.updateDepthIdent(models, this.init.initDepth);
    }
    /**
     * @param {?} models
     * @param {?} depth
     * @return {?}
     */
    updateDepthIdent(models, depth) {
        return models.map(item => {
            const /** @type {?} */ nextID = item.id || makeRandomID();
            const /** @type {?} */ nextChildren = notEmptyArray(item.children)
                ? this.updateDepthIdent(item.children, depth + 1) : [];
            const /** @type {?} */ nextIndeterminate = !!nextChildren.find(item => item.checked || item._indeterminate);
            const /** @type {?} */ allChecked = nextChildren.length > 0 && !nextChildren.find(item => !item.checked);
            return Object.assign({}, item, {
                id: nextID,
                checked: allChecked || this.isChecked(nextID, item),
                _level: depth ? depth + 1 : 1,
                expanded: this.isExpanded(nextID, item),
                _indeterminate: allChecked ? false : nextIndeterminate,
                children: nextChildren,
            });
        });
    }
    /**
     * @param {?} id
     * @param {?} item
     * @return {?}
     */
    isExpanded(id, item) {
        if (item.expanded === true)
            return true;
        if (this.init.defaultExpandAll)
            return true;
        if (!this.init.defaultExpandedKeys.length)
            return false;
        return !!this.init.defaultExpandedKeys.find(key => key === id);
    }
    /**
     * @param {?} id
     * @param {?} item
     * @return {?}
     */
    isChecked(id, item) {
        if (item.checked === true)
            return true;
        if (!this.init.defaultCheckedKeys.length)
            return false;
        return !!this.init.defaultCheckedKeys.find(key => key === id);
    }
}
function ModelStandard_tsickle_Closure_declarations() {
    /** @type {?} */
    ModelStandard.prototype.init;
}
//# sourceMappingURL=utils.js.map